> 신용권 저자 한빛미디어 출판의 '혼자 공부하는 자바' 를 보고 정리, 공부한 내용입니다.

# 자바 시작하기
* 책에서는 jdk-11.0.2 기준으로 사용되었고, 실습은 jdk-11.0.19로 진행했다.
Java 8 이상의 JDK라면 공통적으로 적용되는 내용이다. Eclipse는 2022-12 버전을 사용했다.
## 프로젝트 생성
### module-info.java
* JavaSE-11(JDK 11) 이후 버전부터 생성되는 파일이다. 이클립스가 생성하는 프로젝트는 모듈로 만들어지기 때문에 모듈 기술자(Module Descriptor)라고 부르는 module-info.java가 필요하다.
```java
module chap01 {
    // Java SE가 사용하는 모든 모듈이 필요함
    requires java.se;
}
```
* 편집 뷰에서 위와 같은 내용을 입력해 Java SE(JDK)가 제공하는 모든 모듈이 필요함을 명시한다.

### Package 생성
* 자바는 소스 및 컴파일된 바이트 코드 파일들을 **기능별로 쉽게 관리**하기 위해 패키지(Package)를 사용, 클래스명의 **고유성** 보장
* 파일 시스템의 폴더(디렉토리)와 비슷
* **JDK 11 이후 버전**부터는 직접 생성하는 프로젝트도 모듈로 활용할 수 있기 때문에 반드시 패키지를 요구
* JDK 8 이전 버전에서는 꼭 필요하진 않지만, JDK 버전에 상관없이 패키지를 만드는 것이 좋다.

#### Package 명명규칙
1. 명칭은 소문자를 사용한다. 대문자는 사용하지 않는 게 좋다.
2. 소스 파일들을 각각의 그룹으로 구분하기 위해 점(.)으로 구분한다.
3. 패키지 이름으로 소스가 들어가는 폴더가 자동으로 만들어진다.
##### 예시
* ```com.회사이름.프로그램```
* ```com.회사이름.플랫폼.프로그램```
* ```kr.co.회사이름.프로그램```
* ```kr.co.회사이름.플랫폼.프로그램```

### 명령 라인에서 컴파일하고 실행하기
* 이클립스는 소스 파일을 저장하면 자동으로 컴파일하고 쉽게 자바 프로그램을 실행시켜 줌
* 명령 프롬프트 또는 터미널 같은 CLI 환경에서 명령어로 실행시키는 방법

1. 해당 프로젝트 폴더에 들어간다.
   * src 폴더에는 소스 파일(.java), bin 폴더에는 바이트 코드 파일(.class)이 저장되어 있다. 
   * 만약 이미 컴파일 되어 bin 폴더가 비어있지 않다면, 안에 있는 내용을 모두 지워준다(컴파일이 제대로 되었는지 확인하기 위함이다. 반드시 해줄 필요는 없다.)
2. 명령 프롬프트를 실행하고 해당 폴더로 이동한다.


   ```cd C:\JavaStudy\chap01```

3. src 폴더에 있는 소스 파일을 ```javac``` 명령어로 컴파일해서 바이트 코드 파일을 bin 폴더에 생성한다. JDK 8 이전 버전과 JDK 11 이후 버전에서 ```javac``` 명령어를 사용하는 방법이 다르다.
    #### JDK 8 이전 버전
    ```javac -d [바이트 코드 파일 저장 위치] [소스 경로/*.java]```

    ```javac -d bin src/sec03/exam01/*.java```

    javac 명령어로 src 폴더에 있는 소스 파일을 컴파일하고, ```tree /f /a``` 명령어를 실행하면 bin 폴더에 바이트 코드 파일이 생성된 것을 확인할 수 있다.

    #### JDK 11 이후 버전
    ```javac -d [바이트 코드 파일 저장 위치] [소스 경로/module-info.java 소스 경로/*.java]```
    
    ```javac -d bin src/module-info.java src/sec03/exam01/*.java```

    JDK 11 이후 버전부터는 모듈 기술자(module-info.java)도 컴파일 대상에 반드시 포함시켜야 한다. 모든 기술자에 ```requires``` 키워드로 의존성 모듈이 기술되어 있기 때문이다. 이후 과정은 JDK 8과 같다.

4. 코드 파일을 실행한다. 코드 파일도 컴파일과 마찬가지로 JDK 8과 11 이후 버전 명령어가 다르다.
    #### JDK 8 이전 버전
    ```javac -cp [바이트 코드 파일 저장 위치] [패키지이름...클래스이름]```

    ```java -cp bin sec03.exam01.Hello```

    .class는 생략한다.

    #### JDK 11 이후 버전
    ```javac -p [바이트 코드 파일 저장 위치] -m 모듈/패키지이름...클래스이름```
    
    ```java -p bin -m chap01/sec03.exam01.Hello```

    JDK 11 이후 버전부터 실행 방식이 달라진 이유 역시 모듈 기술자를 읽기 위해서이다. 
    
    -m 옵션 뒤의 chap01이 모듈명인데, 모듈 기술자의 모듈명과 동일할 경우 JVM은 모듈 기술자의 내용을 읽고 바이트 코드 파일을 실행할 때 의존성 모듈을 참고한다.

# 변수와 타입
> 컴퓨터 메모리(RAM)에 값을 어디에, 어떻게 저장할지 정해놓기 위해 **변수**라는 개념을 사용

* 메모리에 값을 저장하고 싶다면 변수를 선언하고 변수에 값을 저장한다.
* 메모리에 어디에, 어떻게 저장할지는 프로그래밍 언어와 운영체제가 결정
* 자바의 경우 **JVM**이 하는 일

## 기본 타입(Primitive Type)


| 구분 | 저장되는 값에 따른 분류 | 타입의 종류 |
| --- | --- | --- |
| 기본 타입 | 정수 타입 | byte, char, short, int, long |
|  | 실수 타입 | float, double |
|  | 논리 타입 | boolean |

### 정수 타입

| 타입 |  메모리 사용 크기 | 저장되는 값의 허용 범위 |
| --- | --- | --- |
| byte | 1byte | -128 ~ 127 |
| short | 2byte | -32,768 ~ 32,767 |
| char | 2byte | 0 ~ 65535(유니코드) |
| int | 4byte | -2,147,483,648 ~ 2,147,483,647 |
| long | 8byte | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |

#### 👀 정수 리터럴
* 프로그래머에 의해 직접 입력된 값

기본적으로 컴파일러는 정수 리터럴을 int 타입으로 간주하기 때문에, 정수 리터럴이 int 타입의 허용 범위를 초과할 경우 long 타입임을 컴파일러에게 알려주어야 함

```java
long balance = 30000000000; // 컴파일 에러
long balance = 30000000000L;
```

#### char 타입
* 하나의 문자를 작은따옴표(')로 감싼 것 - **문자 리터럴**
* 문자 리터럴은 유니코드로 변환되어 저장(2byte로 표현할 수 있는 숫자로 매핑한 국제 표준 규약)
* 유니코드는 정수이므로 char로 정수 타입에 속함
* 10진수, 16진수 형태로 유니코드 저장 가능
```java
char c = 65; // 10진수
char c = 0x0041; // 16진수
```

##### 🤔 문자 리터럴을 int 타입에 저장하면?
작은 따옴표로 감싼 문자 리터럴은 유니코드로 변환되기 때문에 int타입 변수에도 저장 가능.
char 'A' 는 A로 출력되지만, int 'A'는 65로 출력


### 실수 타입
* 자바는 실수 리터럴을 **기본적으로 double 타입으로 해석**하기 때문에 double 타입 변수에 저장해야 한다. 실수 리터럴을 float 타입 변수에 저장하면 컴파일 에러 발생
* 실수 리터럴을 float 타입으로 저장하고 싶다면 리터럴 뒤에 소문자 f나 대문자 F를 붙여 컴파일러가 float 타입임을 알 수 있도록 해야함
```java
float var = 3.14; // 컴파일 에러(Type mismatch: cannot convert from double to float)
double var = 3.14;
double var = 314e-2;
```

## 변수와 시스템 입출력
### 모니터로 변수값 출력하기
* ```System.out```의 ```print(), println(), printf("형식문자열", 값1, 값2...)``` 를 사용해 출력 가능
```java
printf($[argument_index$] [flags] [width] [.precision] conversion)
// 값의 순번, -,0, 전체 자릿수, 소수 자릿수, 변환 문자
```

### 키보드에서 입력된 내용을 변수에 저장하기
* 키코드를 읽기 위해서 ```System.in.read()``` 메소드 사용
* Enter 키는 CR(13)과 LF(10)를 반환
* 그러나, 키코드를 하나씩 읽기 때문에 2개 이상의 키가 조합된 한글을 읽을 수 없고 키보드로부터 입력된 내용을 통 문자열로 읽지 못함
* 따라서 자바는 ```Scanner``` 클래스 제공
```java
// scanner 변수를 선언하고, 시스템의 입력 장치로부터 읽는 Scanner를 생성한 뒤 생성된 Scanner를 변수에 저장
Scanner scanner = new Scanner(System.in);

// Enter키 이전까지 입력된 문자열을 읽고 읽은 문자열을 String 변수에 저장
String inputData = scanner.nextLine();
```

#### 🤔 ==과 equals
자바는 기본 타입(byte, short, int, long, float, double, boolean)의 값이 동일한지 비교할 때에는 ==를 사용하고, 문자열(String)이 동일한지 비교할 때에는 equals() 메소드 사용